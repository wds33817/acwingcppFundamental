bit calc:

n >> k & 1;
lowbit(n) = n & -n;



#include<iostream>
#include<string.h>

using namespace std;

int main(){
    int n = 10; // 1010 >> 1  =  101        1010 >> 2  =  10         1010 >> 3  =  1
    for (int k = 3; k >= 0; k--) cout << (n >> k & 1);
    // 如果一个数右移零位则不移动 右移一位，右移两位，右移三位
    return 0;
}


lowbit 是树状数组的基本操作


/*

    计算机中使用补码来表示有符号整数。对于一个给定的整数，其补码的计算步骤如下：

1. **正整数的补码：** 对于正整数，其补码就是其二进制表示本身。

2. **负整数的补码：**
   - **取绝对值：** 首先，取这个负数的绝对值，得到其对应的正整数。
   - **取反：** 将这个正整数的二进制表示中的每一位取反，即将 "0" 变为 "1"，"1" 变为 "0"。
   - **加一：** 将上一步得到的结果加1。

举例说明：

假设要计算 `-5` 的补码：

1. 取绝对值：`5` 的二进制表示是 `00000101`。
2. 取反：`11111010`。
3. 加一：`11111011`。

所以，`-5` 的补码是 `11111011`。

需要注意的是，计算机中的整数通常用固定位数表示，比如8位、16位、32位或者64位。在进行补码计算时，需要根据固定的位数截断或者扩展二进制表示。

*/

#include <iostream>

int lowbit(int x) {
    return x & -x; // -x = (~x + 1) 取反
}

int main() {
    int n = 10; // 二进制表示: 1010
    int result = lowbit(n);
    
    std::cout << n << " 的 lowbit 是: " << result << std::endl;

    return 0;
}

