负数-x的补码：绝对值x的原码的反码再加1。 为什么还要加1
ChatGPT
在二进制补码系统中，加1的目的是为了解决0的表示问题。让我们具体看一下为什么要加1。

原码和反码的问题：

原码是一个数的直接二进制表示，而反码是原码的每一位取反（0变为1，1变为0）。
负数的原码是在正数的原码的基础上将符号位（最高位）改为1。
负数的反码就是负数的原码的每一位取反。
解决0的表示问题：

在补码系统中，0的表示没有正负之分。因此，为了让负数的表示更加一致，需要在反码的基础上再加1。
确保补码系统的一致性：

加1确保了在负数和正数的加法运算中，最终的进位可以被正确处理。
通过在反码的基础上加1，可以确保在计算机中更容易进行加法和减法运算，同时处理正数和负数的情况，避免了0的表示问题。这种设计简化了电路的实现，提高了运算的效率。



在 C++ 中，条件表达式中使用的是整数值。在条件判断中，整数值为0时被视为假（false），非零值被视为真（true）。

原码：将一个整数，转换成二进制，就是其原码。

如单字节的5的原码为：0000 0101；-5的原码为1000 0101。



反码：正数的反码就是其原码；负数的反码是将原码中，除符号位以外，每一位取反。

如单字节的5的反码为：0000 0101；-5的反码为1111 1010。



补码：正数的补码就是其原码；负数的反码+1就是补码。

如单字节的5的补码为：0000 0101；-5的原码为1111 1011。



在计算机中，正数是直接用原码表示的，如单字节5，在计算机中就表示为：0000 0101。

负数用补码表示，如单字节-5，在计算机中表示为1111 1011。

这儿就有一个问题，为什么在计算机中，负数用补码表示呢？为什么不直接用原码表示？如单字节-5：1000 0101。



我想从软件上考虑，原因有两个：

　1、表示范围

　　拿单字节整数来说，无符号型，其表示范围是[0,255]，总共表示了256个数据。有符号型，其表示范围是[-128,127]。

　　先看无符号，0表示为0000 0000，255表示为1111 1111，刚好满足了要求，可以表示256个数据。

　　再看有符号的，若是用原码表示，0表示为0000 000。因为咱们有符号，所以应该也有个负0（虽然它还是0）：1000 0000。

　　那我们看看这样还能够满足我们的要求，表示256个数据么？

　　正数，没问题，127是0111 1111，1是0000 0001，当然其它的应该也没有问题。

　　负数呢，-1是1000 0001，那么把负号去掉，最大的数是111 1111，也就是127，所以负数中最小能表示的数据是-127。

　　这样似乎不太对劲，该如何去表示-128？貌似直接用原码无法表示，而我们却有两个0。

　　如果我们把其中的一个0指定为-128，不行么？这也是一个想法，不过有两个问题：一是它与-127的跨度过大；二是在用硬件进行运算时不方便。

　　所以，计算机中，负数是采用补码表示。

如 单字节-1，原码为1000 0001，反码为1111 1110，补码为1111 1111，计算机中的单字节-1就表示为1111 1111。

　　单字节-127，原码是1111 1111，反码1000 0000，补码是1000 0001，计算机中单字节-127表示为1000 0001。

单字节-128，原码貌似表示不出来，除了符号为，最大的数只能是127了，其在计算机中的表示为1000 0000。



　2、大小的习惯（个人观点）

　　也可以从数据大小上来理解。还是以单字节数据为例。有符号数中，正数的范围是[1,127]，最大的是127，不考虑符号为，其表示为111 1111；最小的是1，不考虑符号为，其表示为000 0001。

　　负数中，最大的是-1，我们就用111 1111表示其数值部分。后面的数据依次减1。减到000 0001的时候，我们用它标示了-127。再减去1，就变成000 0000了。还好我们有符号为，所以有两个0。把其中带符号的0拿过来，表示-128，刚好可以满足表示范围。

　 以上只是从软件的角度进行了分析，当然，从硬件的角度出发，负数使用补码表示也是有其原因的，毕竟计算机中，最终实现运算的还是硬件。

主要原因有三：

　　1>、负数的补码，与其对应正数的补码之间的转换可以用同一种方法----求补运算完成，简化硬件。

　　如 原码 反码 补码

　　-127 -〉127 1000 0001 -〉 0111 1110 -〉 0111 1111

127 -〉-127 0111 1111 -〉 1000 0000 -〉 1000 0001

　　-128 -〉128 1000 0000 -〉 0111 1111 -〉 1000 0000

　　128 -〉-128 1000 0000 -〉 0111 1111 -〉 1000 0000

　　可以发现，负数和正数求补的方法是一样的。



　　2>、可以将减法变为加法，省去了减法器。

　　在计算机中，我们可以看到，对其求补，得到的结果是其数值对应的负数。同样，负数也是如此。

　　运算中，减去一个数，等于加上它的相反数，这个小学就学过了。既然其补码就是其相反数，我们加上其补码不就可以了。

　　如：A - 127，

　　也就相当于：A + (-127)，

　　又因为负数是以补码的形式保存的，也就是负数的真值是补码，既然这样，当我们要减一个数时，直接把其补码拿过来，加一下，就OK了，我们也可以放心地跟减法说拜拜了！

　　当然这也涉及到类型转换的问题，如单字节128，其原码是1000 0000，其补码也是1000 0000。这样我们+128，或者-128，都是拿1000 0000过来相加，这样不混乱掉了？还好，各个编程语言的编辑器对有类型转换相关的限制。

　　如：（假设常量都是单字节）

　　1 + 128， 真值的运算是 0000 0001 + 1000 0000 ，如果你将结果赋值给一个单字节有符号正数，编辑器会提示你超出了表示范围。因为运算的两个数据是无符号的，其结果也是无符号的129，而有符号单字节变量最大可以表示的是127。

　　1 - 128，真知的运算是 0000 0001 + 1000 0000 ，因为-128是有符号，其运算结果也是有符号，1000 0001，刚好是-127在计算机中的真值。

　　3>、无符号及带符号的加法运算可以用同一电路完成。

　　有符号和无符号的加减，其实都是把它们的真值拿过来相加。真值，也就是一个数值在计算机中的二进制表示。正数的真值就是其原码，负数的真值是其补码。所以，有符号和无符号由编译器控制，计算机要做的不过是把两个真值拿过来相加。

#include<iostream>

using namespace std;

int main() {
    int a,b,c,d;
    
    // 用空格隔开 and  输入共四行，第一行包含整数 A，第二行包含整数 B，第三行包含整数 C，第四行包含整数 D。
    cin >> a >> b >> c >> d; 
    //scanf("%d%d%d%d", &a, &b, &c, &d);//
    cout << "DIFERENCA = " << (a * b) - (c * d) << endl;
}


#include <cstdio>

int main()
{
    int a, b, c, d;
    scanf("%d%d%d%d", &a, &b, &c, &d);
    printf("DIFERENCA = %d\n", a * b - c * d);
    return 0;
}

#include <cstdio>

using namespace std;

int main()
{
    double pi = 3.14159, r;
    scanf("%lf", &r);
    printf("A=%.4lf\n", pi * r * r);

    return 0;
}

#include <bits/stdc++.h>
using namespace std;
int main()
{
    double a, b, c;
    cin >> a >> b >> c;
    printf("NUMBER = %.0lf\nSALARY = U$ %.2lf",a,b*c);
    return 0;
}




616
#include<iostream> 
#include<cmath>

using namespace std;

int main() {
    double a,b,c,d,res;
    
    cin >> a >> b >> c >> d;
    res = sqrt(pow(a-c, 2) + pow(b-d, 2));
    printf("%.4lf", res);
}
